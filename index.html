<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SHOWING</title>

  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='0.9em' font-size='90'%3E%F0%9F%93%B1%3C/text%3E%3C/svg%3E">

  <meta name="theme-color" content="#000000" />

  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background: #000; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }

    .screen {
      position: fixed; inset: 0;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      gap: 16px;
      padding: 24px;
      box-sizing: border-box;
      background: #000;
      color: #fff;
      text-align: center;
    }

    .hidden { display: none !important; }

    button {
      font-size: 20px;
      padding: 14px 18px;
      border-radius: 14px;
      border: 1px solid #444;
      background: #111;
      color: #fff;
    }
    button:active { transform: translateY(1px); }

    .hint { opacity: 0.75; max-width: 42rem; line-height: 1.35; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    #stage {
      position: fixed; inset: 0;
      background: #000;
      color: #fff;
    }

    /* Centered stacked layer */
    #layer {
      position: absolute; inset: 0;
      display: grid;
      place-items: center;
      text-align: center;
      padding: 24px;
      box-sizing: border-box;
    }

    #textCue, #audioCue, #voteWrap {
      grid-area: 1 / 1;
    }

    #textCue {
      white-space: pre-wrap;
      word-break: break-word;
      line-height: 1.08;
      width: 100%;
    }

    #imgCue {
      position: absolute; inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: none;
    }

    #audioCue {
      display: none;
      font-size: 96px;
      line-height: 1;
    }

    /* Vote UI */
    #voteWrap {
      display: none;
      width: min(920px, 100%);
      padding: 16px;
      box-sizing: border-box;
    }

    #voteGrid {
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      align-items: stretch;
    }

    .voteBtn {
      width: 100%;
      font-size: 22px;
      padding: 18px 16px;
      border-radius: 18px;
      border: 1px solid #555;
      background: #0f0f0f;
      color: #fff;
      line-height: 1.15;
      white-space: normal;
      word-break: break-word;
      min-height: 68px;
    }

    .voteBtn:active { transform: translateY(1px); }

    /* Debug UI */
    #debugWrap {
      position: fixed; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.65);
      color: rgba(255,255,255,0.88);
      font-size: 12px;
      box-sizing: border-box;
      backdrop-filter: blur(6px);
      border-top: 1px solid rgba(255,255,255,0.12);
    }

    #debugBar {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
    }

    #debugLog {
      max-height: 34vh;
      overflow: auto;
      padding: 0 12px 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap;
      line-height: 1.25;
      opacity: 0.95;
    }

    .safePad {
      padding-bottom: calc(24px + env(safe-area-inset-bottom));
      padding-top: calc(24px + env(safe-area-inset-top));
    }
  </style>
</head>

<body>
  <div id="welcome" class="screen safePad">
    <div id="welcomeTitle" style="font-size: 22px; font-weight: 650;">SHOWING</div>
    <div id="welcomeInfo" class="hint"></div>
    <button id="startBtn">Sind Sie bereit?</button>
    <div id="welcomeTip" class="hint">
      Tip: <span class="mono">?p=1</span>, <span class="mono">?p=2</span>, ‚Ä¶ or <span class="mono">?p=random</span>.
      Add <span class="mono">&debug=true</span> for diagnostics.
    </div>
    <div id="welcomeError" class="hint" style="color:#ffb3b3;"></div>
  </div>

  <div id="stage" class="hidden">
    <img id="imgCue" alt="" />
    <div id="layer" class="safePad" aria-live="polite">
      <div id="textCue"></div>
      <div id="audioCue" aria-hidden="true">üîä</div>

      <div id="voteWrap">
        <div id="voteGrid"></div>
      </div>
    </div>
  </div>

  <div id="debugWrap" class="hidden">
    <div id="debugBar">
      <div id="dbgLeft"></div>
      <div id="dbgRight"></div>
    </div>
    <div id="debugLog"></div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  function parseQuery() {
    const u = new URL(window.location.href);
    const dbg = (u.searchParams.get("debug") || "").toLowerCase();
    const pRaw = (u.searchParams.get("p") || "1").toLowerCase().trim();
    return {
      csv: u.searchParams.get("csv") || "",
      pRaw,
      debug: (dbg === "1" || dbg === "true" || dbg === "yes"),
      voteUrl: u.searchParams.get("vote") || "",  // Apps Script Web App /exec
      showId: u.searchParams.get("show") || ""    // optional label stored with votes
    };
  }

  function nowLocalHMS() {
    const d = new Date();
    const hh = String(d.getHours()).padStart(2, "0");
    const mm = String(d.getMinutes()).padStart(2, "0");
    const ss = String(d.getSeconds()).padStart(2, "0");
    return `${hh}:${mm}:${ss}`;
  }

  function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  function isIOS() {
    return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  }
  function isStandaloneIOS() {
    return window.navigator.standalone === true;
  }

  function getOrCreateSessionId() {
    try {
      const k = "showing_session_id_v1";
      let v = localStorage.getItem(k);
      if (!v) {
        v = (crypto?.randomUUID?.() || `${Date.now()}-${Math.random()}`);
        localStorage.setItem(k, v);
      }
      return v;
    } catch (_) {
      return (crypto?.randomUUID?.() || `${Date.now()}-${Math.random()}`);
    }
  }

  // Minimal CSV parser (handles quotes + embedded newlines)
  function parseCSV(text) {
    const rows = [];
    let row = [];
    let cell = "";
    let inQuotes = false;

    for (let i = 0; i < text.length; i++) {
      const c = text[i];
      const n = text[i + 1];

      if (c === '"' && inQuotes && n === '"') { cell += '"'; i++; continue; }
      if (c === '"') { inQuotes = !inQuotes; continue; }

      if (!inQuotes && (c === "," || c === "\n" || c === "\r")) {
        if (c === "\r" && n === "\n") i++;
        row.push(cell.trim());
        cell = "";
        if (c !== ",") {
          if (row.some(v => v.length > 0)) rows.push(row);
          row = [];
        }
        continue;
      }

      cell += c;
    }

    if (cell.length || row.length) {
      row.push(cell.trim());
      if (row.some(v => v.length > 0)) rows.push(row);
    }

    return rows;
  }

  // timeSpec: "0:0:0+6s" or "20:34:00+23s"
  // Optional repeat: "0:0:0+3(r10)s" => repeat action every 10s until next cue.
  function parseCueLine(line) {
    const trimmed = (line || "").trim();
    if (!trimmed) return null;

    const m0 = trimmed.match(/^(\S+)\s+([\s\S]+)$/);
    if (!m0) return { raw: trimmed, error: "Missing whitespace between timeSpec and action." };

    const timeSpec = m0[1].trim();
    const actionSpec = m0[2].trim();

    const m = timeSpec.match(/^(\d{1,2}):(\d{1,2}):(\d{1,2})\+(\d+)(?:\(r(\d+)\))?s$/);
    if (!m) return { raw: trimmed, error: `Bad timeSpec: "${timeSpec}"` };

    const hh = parseInt(m[1], 10);
    const mm = parseInt(m[2], 10);
    const ss = parseInt(m[3], 10);
    const plus = parseInt(m[4], 10);
    const repeatEvery = m[5] ? parseInt(m[5], 10) : null;

    const actionMatch = actionSpec.match(/^([A-Z&]+)=([\s\S]*)$/);
    if (!actionMatch) return { raw: trimmed, error: `Bad actionSpec: "${actionSpec}"` };

    const kind = actionMatch[1].trim().toUpperCase();
    const payload = (actionMatch[2] || "").trim();

    let action = { kind, payload };

    if (kind === "SOUND&IMAGE") {
      const parts = payload.split(/\s+/).filter(Boolean);
      if (parts.length < 2) return { raw: trimmed, error: "SOUND&IMAGE needs soundUrl and imageUrl." };
      action = { kind, soundUrl: parts[0], imageUrl: parts.slice(1).join(" ") };
    } else if (kind === "SOUND&TEXT") {
      const parts = payload.split(/\s+/).filter(Boolean);
      if (parts.length < 2) return { raw: trimmed, error: "SOUND&TEXT needs a soundUrl then text." };
      action = { kind, soundUrl: parts[0], text: parts.slice(1).join(" ") };
    } else if (kind === "SOUND") {
      action = { kind, soundUrl: payload };
    } else if (kind === "IMAGE") {
      action = { kind, imageUrl: payload };
    } else if (kind === "TEXT") {
      action = { kind, text: payload };
    } else if (kind === "CMD") {
      action = { kind, command: payload };
    } else if (kind === "VOTE") {
      action = { kind, voteSpec: payload };
    }

    return { raw: trimmed, timeSpec: { hh, mm, ss, plus }, repeatEvery, action };
  }

  function computeDuePerfMs(timeSpec, startDate, startPerfNow) {
    const { hh, mm, ss, plus } = timeSpec;
    const isRelative = (hh === 0 && mm === 0 && ss === 0);

    if (isRelative) return startPerfNow + plus * 1000;

    const base = new Date(startDate);
    base.setHours(hh, mm, ss, 0);
    const dueWall = new Date(base.getTime() + plus * 1000);

    if (dueWall.getTime() < startDate.getTime()) dueWall.setDate(dueWall.getDate() + 1);

    return startPerfNow + (dueWall.getTime() - startDate.getTime());
  }

  const els = {
    welcome: $("welcome"),
    welcomeTitle: $("welcomeTitle"),
    welcomeInfo: $("welcomeInfo"),
    welcomeTip: $("welcomeTip"),
    welcomeError: $("welcomeError"),
    startBtn: $("startBtn"),
    stage: $("stage"),
    layer: $("layer"),
    textCue: $("textCue"),
    imgCue: $("imgCue"),
    audioCue: $("audioCue"),
    voteWrap: $("voteWrap"),
    voteGrid: $("voteGrid"),
    debugWrap: $("debugWrap"),
    dbgLeft: $("dbgLeft"),
    dbgRight: $("dbgRight"),
    debugLog: $("debugLog"),
  };

  function clearStage() {
    els.textCue.textContent = "";
    els.textCue.style.display = "block";
    els.textCue.style.fontSize = "24px";
    els.imgCue.style.display = "none";
    els.imgCue.src = "";
    els.audioCue.style.display = "none";
    els.voteWrap.style.display = "none";
    els.voteGrid.innerHTML = "";
  }

  function fitTextToBox(text) {
    els.textCue.textContent = text;

    const boxW = els.layer.clientWidth - 48;
    const boxH = els.layer.clientHeight - 48;

    let lo = 10, hi = 240, best = lo;
    while (lo <= hi) {
      const mid = Math.floor((lo + hi) / 2);
      els.textCue.style.fontSize = mid + "px";
      const r = els.textCue.getBoundingClientRect();
      const fits = (r.width <= boxW + 1) && (r.height <= boxH + 1);
      if (fits) { best = mid; lo = mid + 1; }
      else { hi = mid - 1; }
    }
    els.textCue.style.fontSize = best + "px";
  }

  function isDebugOnlyText(action) {
    if (!action || action.kind !== "TEXT") return false;
    return (action.text || "").trim().startsWith("VERSION=");
  }

  async function playSound(url, audioCtx, debugLogFn) {
    const cleanUrl = (url || "").trim();
    if (!cleanUrl) return;

    if (location.protocol === "https:" && cleanUrl.startsWith("http:")) {
      debugLogFn?.(`Audio blocked (mixed content): ${cleanUrl}`);
      throw new Error("Mixed content (http audio on https page).");
    }

    if (audioCtx) {
      try {
        const res = await fetch(cleanUrl, { mode: "cors", cache: "no-store" });
        if (!res.ok) throw new Error(`Fetch ${res.status} ${res.statusText}`);
        const buf = await res.arrayBuffer();
        const audioBuffer = await audioCtx.decodeAudioData(buf);
        const src = audioCtx.createBufferSource();
        src.buffer = audioBuffer;
        src.connect(audioCtx.destination);
        src.start();
        debugLogFn?.(`WebAudio OK: ${cleanUrl}`);
        return;
      } catch (e) {
        debugLogFn?.(`WebAudio failed: ${e.message}`);
      }
    }

    const a = new Audio(cleanUrl);
    a.preload = "auto";
    a.crossOrigin = "anonymous";
    await a.play();
    debugLogFn?.(`HTMLAudio OK: ${cleanUrl}`);
  }

  function parseInlineAction(actionStr) {
    const s = (actionStr || "").trim();
    const m = s.match(/^([A-Z&]+)=([\s\S]*)$/);
    if (!m) return null;

    const kind = m[1].trim().toUpperCase();
    const payload = (m[2] || "").trim();

    if (kind === "SOUND&IMAGE") {
      const parts = payload.split(/\s+/).filter(Boolean);
      if (parts.length < 2) return null;
      return { kind, soundUrl: parts[0], imageUrl: parts.slice(1).join(" ") };
    }
    if (kind === "SOUND&TEXT") {
      const parts = payload.split(/\s+/).filter(Boolean);
      if (parts.length < 2) return null;
      return { kind, soundUrl: parts[0], text: parts.slice(1).join(" ") };
    }
    if (kind === "SOUND") return { kind, soundUrl: payload };
    if (kind === "IMAGE") return { kind, imageUrl: payload };
    if (kind === "TEXT") return { kind, text: payload };
    if (kind === "CMD") return { kind, command: payload };
    if (kind === "VOTE") return { kind, voteSpec: payload };
    return { kind, payload };
  }

  // Parses: [Option A](TEXT=...) [Option B](IMAGE=...) ...
  // Allows whitespace/newlines between parts.
  function parseVoteSpec(spec) {
    const s = (spec || "").trim();
    const out = [];

    let i = 0;
    while (i < s.length) {
      // find '['
      const lb = s.indexOf("[", i);
      if (lb < 0) break;
      const rb = s.indexOf("]", lb + 1);
      if (rb < 0) break;
      const label = s.slice(lb + 1, rb).trim();

      // next non-space should be '('
      let j = rb + 1;
      while (j < s.length && /\s/.test(s[j])) j++;
      if (s[j] !== "(") { i = rb + 1; continue; }

      // parse until matching ')'
      j++; // after '('
      let depth = 1;
      const start = j;
      while (j < s.length && depth > 0) {
        if (s[j] === "(") depth++;
        else if (s[j] === ")") depth--;
        j++;
      }
      if (depth !== 0) break;

      const inner = s.slice(start, j - 1).trim();
      const action = parseInlineAction(inner);
      if (action) out.push({ label, action });

      i = j;
    }

    return out;
  }

  async function showAction(action, audioCtx, debugLog, q) {
    clearStage();

    if (action.kind === "TEXT") {
      if (isDebugOnlyText(action) && !q.debug) return;
      els.textCue.style.display = "block";
      fitTextToBox(action.text || "");
      return;
    }

    if (action.kind === "IMAGE") {
      els.textCue.style.display = "none";
      els.imgCue.style.display = "block";
      els.imgCue.src = action.imageUrl || "";
      return;
    }

    if (action.kind === "SOUND") {
      els.textCue.style.display = "none";
      els.audioCue.style.display = "block";
      await playSound(action.soundUrl || "", audioCtx, debugLog);
      return;
    }

    if (action.kind === "SOUND&IMAGE") {
      els.textCue.style.display = "none";
      els.imgCue.style.display = "block";
      els.imgCue.src = action.imageUrl || "";
      els.audioCue.style.display = "block";
      await playSound(action.soundUrl || "", audioCtx, debugLog);
      return;
    }

    if (action.kind === "SOUND&TEXT") {
      els.textCue.style.display = "block";
      els.audioCue.style.display = "block";
      fitTextToBox(action.text || "");
      await playSound(action.soundUrl || "", audioCtx, debugLog);
      return;
    }

    // VOTE handled elsewhere (needs context)
  }

  function isRefreshCommand(action) {
    if (!action || action.kind !== "CMD") return false;
    const cmd = String(action.command || "").trim().toLowerCase();
    return (cmd === "refreshdata" || cmd === "refresh" || cmd === "refresh-data");
  }

  async function fetchSheetCSV(csvUrl) {
    const u = new URL(csvUrl);
    const buster = (crypto?.randomUUID?.() || `${Date.now()}-${Math.random()}`);
    u.searchParams.set("cb", buster);

    const res = await fetch(u.toString(), {
      mode: "cors",
      cache: "no-store",
      headers: { "Cache-Control": "no-cache", "Pragma": "no-cache" },
    });

    if (!res.ok) throw new Error(`Fetch failed: ${res.status} ${res.statusText}`);
    return await res.text();
  }

  async function fetchSheetCSVWithRetries(csvUrl, debugLog, attempts = 5, delaysMs = [0, 1500, 3000, 6000, 10000]) {
    let lastText = null;
    for (let i = 0; i < attempts; i++) {
      const d = delaysMs[i] ?? 0;
      if (d > 0) { debugLog?.(`Refresh retry ${i + 1}/${attempts}: waiting ${d}ms‚Ä¶`); await sleep(d); }
      else { debugLog?.(`Refresh retry ${i + 1}/${attempts}: fetching‚Ä¶`); }

      const text = await fetchSheetCSV(csvUrl);
      if (lastText !== null && text !== lastText) {
        debugLog?.(`Refresh: detected changed CSV on attempt ${i + 1}.`);
        return text;
      }
      lastText = text;
    }
    debugLog?.(`Refresh: no change detected after ${attempts} attempts; using last fetch.`);
    return lastText;
  }

  function detectPerformerCount(rows) {
    let maxCols = 0;
    for (const r of rows) maxCols = Math.max(maxCols, r.length);

    const available = [];
    for (let c = 0; c < maxCols; c++) {
      let hasAny = false;
      for (let i = 0; i < rows.length; i++) {
        const v = (rows[i][c] || "").trim();
        if (v.length > 0) { hasAny = true; break; }
      }
      if (hasAny) available.push(c + 1);
    }
    return available;
  }

  function pickColumnLines(rows, performerIndex1Based) {
    const col = Math.max(1, performerIndex1Based) - 1;
    return rows.map(r => (r[col] || "").trim()).filter(v => v.length > 0);
  }

  function buildCuesFromLines(lines) {
    const cues = [];
    const errors = [];
    for (const ln of lines) {
      const cue = parseCueLine(ln);
      if (!cue) continue;
      if (cue.error) errors.push(cue);
      else cues.push(cue);
    }
    return { cues, errors };
  }

  async function requestFullscreen() {
    const el = document.documentElement;
    try {
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    } catch (_) {}
  }

  async function castVote(voteUrl, payload, debugLog) {
    if (!voteUrl) {
      debugLog?.("Vote URL missing (add &vote=YOUR_APPS_SCRIPT_EXEC_URL). Vote not sent.");
      return;
    }
    try {
      await fetch(voteUrl, {
        method: "POST",
        mode: "no-cors",                 // important: avoids CORS issues on GH Pages
        headers: { "Content-Type": "text/plain;charset=utf-8" }, // keep it simple
        body: JSON.stringify(payload),
      });
      debugLog?.("Vote sent (no-cors).");
    } catch (e) {
      debugLog?.(`Vote send failed: ${e.message}`);
    }
  }

  async function run() {
    const q = parseQuery();
    const sessionId = getOrCreateSessionId();

    if (q.debug) els.debugWrap.classList.remove("hidden");
    else els.debugWrap.classList.add("hidden");

    const debugLog = (msg) => {
      if (!q.debug) return;
      const line = `[${nowLocalHMS()}] ${msg}`;
      console.log(line);
      els.debugLog.textContent += line + "\n";
      els.debugLog.scrollTop = els.debugLog.scrollHeight;
      els.dbgRight.textContent = `Now ${nowLocalHMS()}`;
    };

    // Optional: hide title+tip unless debug
    if (!q.debug) {
      els.welcomeTitle.classList.add("hidden");
      els.welcomeTip.classList.add("hidden");
    }

    // iOS hint even without debug (only on Safari browser, not standalone)
    if (isIOS() && !isStandaloneIOS()) {
      const msg = document.createElement("div");
      msg.className = "hint";
      msg.style.maxWidth = "32rem";
      msg.style.opacity = "0.7";
      msg.style.fontSize = "14px";
      msg.style.marginTop = "12px";
      msg.textContent = "For a fully immersive experience on iPhone/iPad, use ‚ÄúAdd to Home Screen‚Äù.";
      els.welcome.appendChild(msg);
    }

    if (!q.csv) {
      els.startBtn.disabled = true;
      if (q.debug) els.welcomeInfo.innerHTML = `Missing <span class="mono">?csv=...</span> URL parameter.`;
      return;
    }

    if (q.debug) {
      els.welcomeInfo.innerHTML =
        `CSV: <span class="mono">${q.csv.replaceAll("<","&lt;").replaceAll(">","&gt;")}</span><br>
         p: <span class="mono">${q.pRaw}</span><br>
         vote: <span class="mono">${(q.voteUrl || "(none)").replaceAll("<","&lt;").replaceAll(">","&gt;")}</span><br>
         show: <span class="mono">${q.showId || "(none)"}</span>`;
      els.dbgLeft.textContent = `Loading CSV‚Ä¶`;
    }

    let raw;
    try {
      raw = await fetchSheetCSV(q.csv);
      debugLog(`CSV fetched (${raw.length} chars).`);
    } catch (e) {
      els.startBtn.disabled = true;
      debugLog(`CSV fetch failed: ${e.message}`);
      if (q.debug) els.welcomeError.textContent = `Could not fetch CSV. Error: ${e.message}`;
      return;
    }

    const rows = parseCSV(raw);
    const availablePerformers = detectPerformerCount(rows);
    if (availablePerformers.length === 0) {
      els.startBtn.disabled = true;
      debugLog("No performer columns with any data.");
      if (q.debug) els.welcomeError.textContent = "No performer columns with any data.";
      return;
    }

    let pSelected;
    if (q.pRaw === "random" || q.pRaw === "r") {
      pSelected = availablePerformers[Math.floor(Math.random() * availablePerformers.length)];
      debugLog(`p=random ‚Üí selected performer p=${pSelected} from [${availablePerformers.join(", ")}]`);
    } else {
      const pNum = parseInt(q.pRaw, 10);
      pSelected = Number.isFinite(pNum) && pNum > 0 ? pNum : 1;
      debugLog(`Selected performer p=${pSelected}`);
    }

    let lines = pickColumnLines(rows, pSelected);
    let built = buildCuesFromLines(lines);
    let cues = built.cues;
    let errors = built.errors;

    debugLog(`Rows parsed: ${rows.length}`);
    debugLog(`Available performers: [${availablePerformers.join(", ")}]`);
    debugLog(`Lines in column p=${pSelected}: ${lines.length}`);
    debugLog(`Cues OK: ${cues.length}, errors: ${errors.length}`);

    if (q.debug) {
      els.dbgLeft.textContent = `Loaded ${cues.length} cues (p=${pSelected})`;
      if (errors.length) {
        els.welcomeError.textContent =
          "Some lines could not be parsed:\n" +
          errors.slice(0, 10).map(e => `- ${e.raw}  (${e.error})`).join("\n");
      } else {
        els.welcomeError.textContent = "";
      }
    }

    els.startBtn.addEventListener("click", async () => {
      await requestFullscreen();
      els.welcome.classList.add("hidden");
      els.stage.classList.remove("hidden");

      // Unlock audio
      let audioCtx = null;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        gain.gain.value = 0.00001;
        osc.connect(gain).connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.01);
        await audioCtx.resume();
        debugLog(`AudioContext state: ${audioCtx.state}`);
      } catch (e) {
        debugLog(`AudioContext unavailable/unlock failed: ${e.message}`);
      }

      const startDate = new Date();
      const startPerf = performance.now();
      debugLog(`START pressed. Start wall time: ${startDate.toLocaleTimeString()}`);

      // repeating action state
      let repeatHandle = null;
      let repeatAction = null;
      let scheduleDirty = false;

      const stopRepeat = () => {
        if (repeatHandle !== null) {
          clearInterval(repeatHandle);
          repeatHandle = null;
          repeatAction = null;
          debugLog("Stopped repeating action.");
        }
      };

      const startRepeat = (action, everySeconds) => {
        stopRepeat();
        if (!everySeconds || everySeconds <= 0) return;
        repeatAction = action;
        debugLog(`Repeat ON: every ${everySeconds}s until next cue.`);
        repeatHandle = setInterval(async () => {
          try {
            // Repeating refreshdata keeps reading updated score
            if (repeatAction?.kind === "CMD" && isRefreshCommand(repeatAction)) {
              const newRaw = await fetchSheetCSVWithRetries(q.csv, debugLog);
              const newRows = parseCSV(newRaw);
              const newLines = pickColumnLines(newRows, pSelected);
              const newBuilt = buildCuesFromLines(newLines);
              cues = newBuilt.cues;
              errors = newBuilt.errors;
              scheduleDirty = true;
              debugLog(`Repeat refresh OK: cues=${cues.length}, errors=${errors.length}`);
            } else if (repeatAction?.kind === "VOTE") {
              // don't auto-repeat vote UI; ignore repeats for VOTE
            } else {
              await showAction(repeatAction, audioCtx, debugLog, q);
            }
          } catch (e) {
            debugLog(`Repeat action failed: ${e.message}`);
          }
        }, everySeconds * 1000);
      };

      const firedRaw = new Set();

      const rebuildSchedule = () => {
        const nowPerf = performance.now();
        return cues.map((c, idx) => ({
          idx,
          cue: c,
          duePerfMs: computeDuePerfMs(c.timeSpec, startDate, startPerf)
        }))
        .filter(item => item.duePerfMs > nowPerf + 20 && !firedRaw.has(item.cue.raw))
        .sort((a, b) => a.duePerfMs - b.duePerfMs || a.idx - b.idx);
      };

      const waitUntil = async (targetPerfMs) => {
        while (performance.now() < targetPerfMs) {
          if (scheduleDirty) return false;
          const remaining = targetPerfMs - performance.now();
          await sleep(Math.min(200, Math.max(10, remaining)));
        }
        return true;
      };

      let scheduled = rebuildSchedule();
      debugLog(`Initial pending cues: ${scheduled.length}`);
      let i = 0;

      while (true) {
        if (scheduleDirty) {
          scheduleDirty = false;
          scheduled = rebuildSchedule();
          debugLog(`Schedule rebuilt (dirty). Pending cues: ${scheduled.length}`);
          i = 0;
          if (scheduled.length === 0) break;
        }
        if (i >= scheduled.length) break;

        const item = scheduled[i];
        const ok = await waitUntil(item.duePerfMs);
        if (!ok) continue;

        stopRepeat(); // stop repeat exactly when next cue fires
        firedRaw.add(item.cue.raw);

        if (q.debug) {
          els.dbgLeft.textContent = `Cue ${i + 1}/${scheduled.length} (p=${pSelected})`;
          debugLog(`FIRE: ${item.cue.raw}`);
        }

        const act = item.cue.action;

        // CMD
        if (act.kind === "CMD") {
          if (isRefreshCommand(act)) {
            debugLog("CMD=refreshdata fired.");
            try {
              const newRaw = await fetchSheetCSVWithRetries(q.csv, debugLog);
              const newRows = parseCSV(newRaw);
              const newLines = pickColumnLines(newRows, pSelected);
              const newBuilt = buildCuesFromLines(newLines);
              cues = newBuilt.cues;
              errors = newBuilt.errors;
              debugLog(`Refresh OK: cues=${cues.length}, errors=${errors.length}`);
              scheduleDirty = true;
            } catch (e) {
              debugLog(`Refresh FAILED: ${e.message}`);
            }
          } else {
            debugLog(`CMD ignored/unknown: ${act.command || ""}`);
          }
          if (item.cue.repeatEvery && item.cue.repeatEvery > 0) startRepeat(act, item.cue.repeatEvery);
          i++;
          continue;
        }

        // VOTE
        if (act.kind === "VOTE") {
          clearStage();

          const options = parseVoteSpec(act.voteSpec || "");
          if (!options.length) {
            if (q.debug) debugLog("VOTE parse failed: no options found.");
            i++;
            continue;
          }

          els.voteWrap.style.display = "block";
          els.voteGrid.innerHTML = "";

          // build buttons
          options.forEach((opt, idx) => {
            const b = document.createElement("button");
            b.className = "voteBtn";
            b.type = "button";
            b.textContent = opt.label || `Option ${idx + 1}`;
            b.addEventListener("click", async () => {
              // hide vote UI immediately
              els.voteWrap.style.display = "none";
              els.voteGrid.innerHTML = "";

              // cast vote
              const payload = {
                showId: q.showId,
                sessionId,
                performer: pSelected,
                optionLabel: opt.label,
                optionIndex: idx,
                tsClientIso: new Date().toISOString(),
                userAgent: navigator.userAgent
              };
              await castVote(q.voteUrl, payload, debugLog);

              // execute inline action
              try {
                await showAction(opt.action, audioCtx, debugLog, q);
              } catch (e) {
                debugLog(`Vote inline action failed: ${e.message}`);
              }
            });
            els.voteGrid.appendChild(b);
          });

          // NOTE: repeats are ignored for VOTE (otherwise it would pop back up)
          i++;
          continue;
        }

        // normal visible actions
        try {
          await showAction(act, audioCtx, debugLog, q);
        } catch (e) {
          debugLog(`Action failed: ${e.message}`);
        }

        if (item.cue.repeatEvery && item.cue.repeatEvery > 0) startRepeat(act, item.cue.repeatEvery);

        i++;
      }

      stopRepeat();
      clearStage();
      fitTextToBox("‚Äî end ‚Äî");
      debugLog("END.");
    }, { once: true });
  }

  run();
})();
</script>
</body>
</html>
