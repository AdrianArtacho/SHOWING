<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>ActionScore Player</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background: #000; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }

    .screen {
      position: fixed; inset: 0;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      gap: 16px;
      padding: 24px;
      box-sizing: border-box;
      background: #000;
      color: #fff;
      text-align: center;
    }

    .hidden { display: none !important; }

    button {
      font-size: 20px;
      padding: 14px 18px;
      border-radius: 14px;
      border: 1px solid #444;
      background: #111;
      color: #fff;
    }
    button:active { transform: translateY(1px); }

    .hint { opacity: 0.75; max-width: 42rem; line-height: 1.35; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    /* Main stage */
    #stage {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      background: #000;
      color: #fff;
      padding: 24px;
      box-sizing: border-box;
      text-align: center;
    }

    #textCue {
      white-space: pre-wrap;
      word-break: break-word;
      line-height: 1.08;
      width: 100%;
    }

    #imgCue {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      display: none;
    }

    #audioCue {
      display: none;
      font-size: 96px;
      line-height: 1;
    }

    /* Debug bar + log */
    #debugWrap {
      position: fixed; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.65);
      color: rgba(255,255,255,0.88);
      font-size: 12px;
      box-sizing: border-box;
      backdrop-filter: blur(6px);
      border-top: 1px solid rgba(255,255,255,0.12);
    }

    #debugBar {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
    }

    #debugLog {
      max-height: 34vh;
      overflow: auto;
      padding: 0 12px 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap;
      line-height: 1.25;
      opacity: 0.95;
    }

    #debugWrap a { color: rgba(255,255,255,0.88); }
  </style>
</head>

<body>
  <!-- Welcome / unlock screen -->
  <div id="welcome" class="screen">
    <div id="welcomeTitle" style="font-size: 22px; font-weight: 650;">ActionScore Player</div>
    <div id="welcomeInfo" class="hint"></div>
    <button id="startBtn">Start</button>
    <div id="welcomeTip" class="hint">
      Tip: use <span class="mono">?p=1</span>, <span class="mono">?p=2</span>, <span class="mono">?p=3</span> to choose the performer column.
    </div>
    <div id="welcomeError" class="hint" style="color:#ffb3b3;"></div>
  </div>

  <!-- Main stage -->
  <div id="stage" class="hidden" aria-live="polite">
    <div id="textCue"></div>
    <img id="imgCue" alt="" />
    <div id="audioCue" aria-hidden="true">üéß</div>
  </div>

  <!-- Debug UI (only visible when debug=true) -->
  <div id="debugWrap" class="hidden">
    <div id="debugBar">
      <div id="dbgLeft"></div>
      <div id="dbgRight"></div>
    </div>
    <div id="debugLog"></div>
  </div>

<script>
(() => {
  // ---------- Utilities ----------
  const $ = (id) => document.getElementById(id);

  function parseQuery() {
    const u = new URL(window.location.href);
    const dbg = (u.searchParams.get("debug") || "").toLowerCase();
    return {
      csv: u.searchParams.get("csv") || "",
      p: parseInt(u.searchParams.get("p") || "1", 10), // 1-based performer index
      debug: (dbg === "1" || dbg === "true" || dbg === "yes")
    };
  }

  function nowLocalHMS() {
    const d = new Date();
    const hh = String(d.getHours()).padStart(2, "0");
    const mm = String(d.getMinutes()).padStart(2, "0");
    const ss = String(d.getSeconds()).padStart(2, "0");
    return `${hh}:${mm}:${ss}`;
  }

  function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  // Minimal CSV parser (handles quotes). Good enough for ‚Äúone cue per row‚Äù.
  function parseCSV(text) {
    const rows = [];
    let row = [];
    let cell = "";
    let inQuotes = false;

    for (let i = 0; i < text.length; i++) {
      const c = text[i];
      const n = text[i + 1];

      if (c === '"' && inQuotes && n === '"') { cell += '"'; i++; continue; }
      if (c === '"') { inQuotes = !inQuotes; continue; }

      if (!inQuotes && (c === "," || c === "\n" || c === "\r")) {
        if (c === "\r" && n === "\n") i++; // swallow \n after \r
        row.push(cell.trim());
        cell = "";
        if (c !== ",") {
          if (row.some(v => v.length > 0)) rows.push(row);
          row = [];
        }
        continue;
      }

      cell += c;
    }

    if (cell.length || row.length) {
      row.push(cell.trim());
      if (row.some(v => v.length > 0)) rows.push(row);
    }

    return rows;
  }

  // ---------- Cue Parsing ----------
  // Expected: "<timeSpec> <ACTION=...>"
  // timeSpec examples:
  //  "0:0:0+6s"
  //  "20:34:00+23s"
  // Optional jitter: "0:0:0+3(r10)s" => 3s + rand(0..10)s
  function parseCueLine(line) {
    const trimmed = (line || "").trim();
    if (!trimmed) return null;

    const spaceIdx = trimmed.indexOf(" ");
    if (spaceIdx < 0) {
      return { raw: trimmed, error: "Missing space between timeSpec and action." };
    }

    const timeSpec = trimmed.slice(0, spaceIdx).trim();
    const actionSpec = trimmed.slice(spaceIdx + 1).trim();

    const m = timeSpec.match(/^(\d{1,2}):(\d{1,2}):(\d{1,2})\+(\d+)(?:\(r(\d+)\))?s$/);
    if (!m) {
      return { raw: trimmed, error: `Bad timeSpec: "${timeSpec}"` };
    }

    const hh = parseInt(m[1], 10);
    const mm = parseInt(m[2], 10);
    const ss = parseInt(m[3], 10);
    const plus = parseInt(m[4], 10);
    const jitter = m[5] ? parseInt(m[5], 10) : 0;
    const jitterAdd = jitter > 0 ? Math.floor(Math.random() * (jitter + 1)) : 0;

    const actionMatch = actionSpec.match(/^([A-Z&]+)=(.*)$/);
    if (!actionMatch) {
      return { raw: trimmed, error: `Bad actionSpec: "${actionSpec}"` };
    }

    const kind = actionMatch[1].trim();
    const payload = actionMatch[2].trim();

    let action = { kind, payload };

    if (kind === "SOUND&IMAGE") {
      const parts = payload.split(/\s+/);
      if (parts.length < 2) return { raw: trimmed, error: "SOUND&IMAGE needs two URLs separated by space." };
      action = { kind, soundUrl: parts[0], imageUrl: parts.slice(1).join(" ") };
    } else if (kind === "SOUND&TEXT") {
      const parts = payload.split(/\s+/);
      if (parts.length < 2) return { raw: trimmed, error: "SOUND&TEXT needs a URL then text." };
      action = { kind, soundUrl: parts[0], text: parts.slice(1).join(" ") };
    } else if (kind === "SOUND") {
      action = { kind, soundUrl: payload };
    } else if (kind === "IMAGE") {
      action = { kind, imageUrl: payload };
    } else if (kind === "TEXT") {
      action = { kind, text: payload };
    } else if (kind === "CMD") {
      action = { kind, command: payload };
    }

    return { raw: trimmed, timeSpec: { hh, mm, ss, plus, jitterAdd }, action };
  }

  function computeDuePerfMs(timeSpec, startDate, startPerfNow) {
    const { hh, mm, ss, plus, jitterAdd } = timeSpec;
    const isRelative = (hh === 0 && mm === 0 && ss === 0);

    if (isRelative) {
      const deltaMs = (plus + jitterAdd) * 1000;
      return startPerfNow + deltaMs;
    }

    // Absolute local time: schedule at hh:mm:ss (+ offset), today or tomorrow if passed.
    const base = new Date(startDate);
    base.setHours(hh, mm, ss, 0);
    const dueWall = new Date(base.getTime() + (plus + jitterAdd) * 1000);

    if (dueWall.getTime() < startDate.getTime()) {
      dueWall.setDate(dueWall.getDate() + 1);
    }

    const msFromStart = dueWall.getTime() - startDate.getTime();
    return startPerfNow + msFromStart;
  }

  // ---------- Rendering ----------
  const els = {
    welcome: $("welcome"),
    welcomeTitle: $("welcomeTitle"),
    welcomeInfo: $("welcomeInfo"),
    welcomeTip: $("welcomeTip"),
    welcomeError: $("welcomeError"),
    startBtn: $("startBtn"),
    stage: $("stage"),
    textCue: $("textCue"),
    imgCue: $("imgCue"),
    audioCue: $("audioCue"),
    debugWrap: $("debugWrap"),
    dbgLeft: $("dbgLeft"),
    dbgRight: $("dbgRight"),
    debugLog: $("debugLog"),
  };

  function clearStage() {
    els.textCue.textContent = "";
    els.textCue.style.fontSize = "24px";
    els.imgCue.style.display = "none";
    els.imgCue.src = "";
    els.audioCue.style.display = "none";
  }

  function fitTextToBox(text) {
    els.textCue.textContent = text;

    const boxW = els.stage.clientWidth - 48;
    const boxH = els.stage.clientHeight - 48;

    let lo = 10;
    let hi = 240;
    let best = lo;

    while (lo <= hi) {
      const mid = Math.floor((lo + hi) / 2);
      els.textCue.style.fontSize = mid + "px";
      const r = els.textCue.getBoundingClientRect();
      const fits = (r.width <= boxW + 1) && (r.height <= boxH + 1);

      if (fits) { best = mid; lo = mid + 1; }
      else { hi = mid - 1; }
    }

    els.textCue.style.fontSize = best + "px";
  }

  // Robust audio: WebAudio (fetch+decode) first; fallback to HTMLAudio.
  async function playSound(url, audioCtx, debugLogFn) {
    const cleanUrl = (url || "").trim();
    if (!cleanUrl) return;

    // Mixed content check
    if (location.protocol === "https:" && cleanUrl.startsWith("http:")) {
      debugLogFn?.(`Audio blocked (mixed content): ${cleanUrl}`);
      throw new Error("Mixed content (http audio on https page).");
    }

    // 1) WebAudio path (needs CORS-friendly host)
    if (audioCtx) {
      try {
        const res = await fetch(cleanUrl, { mode: "cors" });
        if (!res.ok) throw new Error(`Fetch ${res.status} ${res.statusText}`);

        const buf = await res.arrayBuffer();
        const audioBuffer = await audioCtx.decodeAudioData(buf);

        const src = audioCtx.createBufferSource();
        src.buffer = audioBuffer;
        src.connect(audioCtx.destination);
        src.start();

        debugLogFn?.(`WebAudio OK: ${cleanUrl}`);
        return;
      } catch (e) {
        debugLogFn?.(`WebAudio failed: ${e.message}`);
        // fall through
      }
    }

    // 2) HTMLAudio fallback
    try {
      const a = new Audio(cleanUrl);
      a.preload = "auto";
      a.crossOrigin = "anonymous";
      await a.play();
      debugLogFn?.(`HTMLAudio OK: ${cleanUrl}`);
    } catch (e) {
      debugLogFn?.(`HTMLAudio failed: ${e.message}`);
      throw e;
    }
  }

  async function showAction(action, audioCtx, debugLog) {
    clearStage();

    if (action.kind === "TEXT") {
      fitTextToBox(action.text || "");
      return;
    }

    if (action.kind === "IMAGE") {
      els.textCue.textContent = "";
      els.imgCue.style.display = "block";
      els.imgCue.src = action.imageUrl || "";
      return;
    }

    if (action.kind === "SOUND") {
      els.textCue.textContent = "";
      els.audioCue.style.display = "block";
      await playSound(action.soundUrl || "", audioCtx, debugLog);
      return;
    }

    if (action.kind === "SOUND&IMAGE") {
      els.textCue.textContent = "";
      els.imgCue.style.display = "block";
      els.imgCue.src = action.imageUrl || "";
      els.audioCue.style.display = "block";
      await playSound(action.soundUrl || "", audioCtx, debugLog);
      return;
    }

    if (action.kind === "SOUND&TEXT") {
      els.audioCue.style.display = "block";
      fitTextToBox(action.text || "");
      await playSound(action.soundUrl || "", audioCtx, debugLog);
      return;
    }

    if (action.kind === "CMD") {
      fitTextToBox(`CMD: ${action.command || ""}`);
      return;
    }

    fitTextToBox(`Unknown action: ${action.kind}`);
  }

  // ---------- CSV Fetch ----------
  async function fetchSheetCSV(csvUrl) {
    const u = new URL(csvUrl);
    u.searchParams.set("_", Date.now().toString()); // cache bust
    const res = await fetch(u.toString(), { mode: "cors" });
    if (!res.ok) throw new Error(`Fetch failed: ${res.status} ${res.statusText}`);
    return await res.text();
  }

  function pickColumn(rows, performerIndex1Based) {
    const col = Math.max(1, performerIndex1Based) - 1;
    return rows
      .map(r => (r[col] || "").trim())
      .filter(v => v.length > 0);
  }

  function buildSchedule(lines) {
    const cues = [];
    const errors = [];
    for (const ln of lines) {
      const cue = parseCueLine(ln);
      if (!cue) continue;
      if (cue.error) errors.push(cue);
      else cues.push(cue);
    }
    return { cues, errors };
  }

  // ---------- Main ----------
  async function run() {
    const q = parseQuery();

    // Default: super-clean welcome (only the button)
    if (!q.debug) {
      els.welcomeTitle.classList.add("hidden");
      els.welcomeInfo.classList.add("hidden");
      els.welcomeTip.classList.add("hidden");
      els.welcomeError.classList.add("hidden");
      els.debugWrap.classList.add("hidden");
    } else {
      els.debugWrap.classList.remove("hidden");
    }

    const debugLog = (msg) => {
      if (!q.debug) return;
      const line = `[${nowLocalHMS()}] ${msg}`;
      console.log(line);
      els.debugLog.textContent += line + "\n";
      els.debugLog.scrollTop = els.debugLog.scrollHeight;
      els.dbgRight.textContent = `Now ${nowLocalHMS()}`;
    };

    if (!q.csv) {
      els.startBtn.disabled = true;
      if (q.debug) {
        els.welcomeTitle.classList.remove("hidden");
        els.welcomeInfo.classList.remove("hidden");
        els.welcomeTip.classList.remove("hidden");
        els.welcomeError.classList.remove("hidden");
        els.welcomeInfo.innerHTML =
          `Missing <span class="mono">?csv=...</span> URL parameter.<br><br>
           Example:<br>
           <span class="mono">index.html?csv=ENCODED_GOOGLE_CSV_URL&p=1&debug=true</span>`;
      }
      return;
    }

    if (q.debug) {
      els.welcomeTitle.classList.remove("hidden");
      els.welcomeInfo.classList.remove("hidden");
      els.welcomeTip.classList.remove("hidden");
      els.welcomeError.classList.remove("hidden");
      els.welcomeInfo.innerHTML =
        `CSV: <span class="mono">${q.csv.replaceAll("<","&lt;").replaceAll(">","&gt;")}</span><br>
         Performer: <span class="mono">p=${q.p}</span>`;
      els.dbgLeft.textContent = `Loading CSV‚Ä¶`;
    }

    let raw;
    try {
      raw = await fetchSheetCSV(q.csv);
      debugLog(`CSV fetched (${raw.length} chars).`);
    } catch (e) {
      els.startBtn.disabled = true;
      debugLog(`CSV fetch failed: ${e.message}`);
      if (q.debug) {
        els.welcomeError.textContent = `Could not fetch CSV. Error: ${e.message}`;
      }
      return;
    }

    const rows = parseCSV(raw);
    const lines = pickColumn(rows, q.p);
    const { cues, errors } = buildSchedule(lines);

    debugLog(`Rows parsed: ${rows.length}`);
    debugLog(`Lines in column p=${q.p}: ${lines.length}`);
    debugLog(`Cues OK: ${cues.length}, errors: ${errors.length}`);

    if (q.debug) {
      els.dbgLeft.textContent = `Loaded ${cues.length} cues (p=${q.p})`;
      if (errors.length) {
        els.welcomeError.textContent =
          "Some lines could not be parsed:\n" +
          errors.slice(0, 10).map(e => `- ${e.raw}  (${e.error})`).join("\n");
      } else {
        els.welcomeError.textContent = "";
      }
      // Show first few cues
      cues.slice(0, 10).forEach((c, i) => debugLog(`Cue[${i}]: ${c.raw}`));
    }

    els.startBtn.addEventListener("click", async () => {
      els.welcome.classList.add("hidden");
      els.stage.classList.remove("hidden");

      // Unlock AudioContext on gesture (best effort)
      let audioCtx = null;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        gain.gain.value = 0.00001;
        osc.connect(gain).connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.01);
        await audioCtx.resume();
        debugLog(`AudioContext state: ${audioCtx.state}`);
      } catch (e) {
        debugLog(`AudioContext unavailable/unlock failed: ${e.message}`);
      }

      const startDate = new Date();
      const startPerf = performance.now();
      debugLog(`START pressed. Start wall time: ${startDate.toLocaleTimeString()}`);

      // Build due times (performance.now space) and sort
      const scheduled = cues.map((c, idx) => ({
        idx,
        cue: c,
        duePerfMs: computeDuePerfMs(c.timeSpec, startDate, startPerf)
      })).sort((a, b) => a.duePerfMs - b.duePerfMs || a.idx - b.idx);

      debugLog(`Scheduled cues: ${scheduled.length}`);

      for (const item of scheduled) {
        const waitMs = Math.max(0, item.duePerfMs - performance.now());
        if (waitMs > 0) await sleep(waitMs);

        els.dbgLeft.textContent = `Cue ${item.idx + 1}/${scheduled.length}`;
        debugLog(`FIRE: ${item.cue.raw}`);

        try {
          await showAction(item.cue.action, audioCtx, debugLog);
        } catch (e) {
          // In debug, show error; otherwise silently continue.
          debugLog(`Action failed: ${e.message}`);
        }
      }

      fitTextToBox("‚Äî end ‚Äî");
      debugLog("END.");
    }, { once: true });
  }

  run();
})();
</script>
</body>
</html>
