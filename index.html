<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">


  <title>SHOWING</title>

  <!-- Best-effort emoji favicon (works in many browsers) -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='0.9em' font-size='90'%3E%F0%9F%93%B1%3C/text%3E%3C/svg%3E">

  <!-- Helps a bit on Android / some browsers -->
  <meta name="theme-color" content="#000000" />

  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background: #000; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }

    .screen {
      position: fixed; inset: 0;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      gap: 16px;
      padding: 24px;
      box-sizing: border-box;
      background: #000;
      color: #fff;
      text-align: center;
    }

    .hidden { display: none !important; }

    button {
      font-size: 20px;
      padding: 14px 18px;
      border-radius: 14px;
      border: 1px solid #444;
      background: #111;
      color: #fff;
    }
    button:active { transform: translateY(1px); }
    button.secondary { font-size: 16px; padding: 10px 14px; opacity: 0.9; }

    .hint { opacity: 0.75; max-width: 42rem; line-height: 1.35; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    /* Main stage */
    #stage {
      position: fixed; inset: 0;
      background: #000;
      color: #fff;
    }

    /* Centered ‚Äústack‚Äù layer:
       text + headphone emoji occupy the same centered grid cell */
    #layer {
      position: absolute; inset: 0;
      display: grid;
      place-items: center;
      text-align: center;
      padding: 24px;
      box-sizing: border-box;
    }

    #textCue, #audioCue {
      grid-area: 1 / 1;
    }

    #textCue {
      white-space: pre-wrap;
      word-break: break-word;
      line-height: 1.08;
      width: 100%;
    }

    /* IMAGE covers whole screen (may crop) */
    #imgCue {
      position: absolute; inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: none;
    }

    /* Headphones centered */
    #audioCue {
      display: none;
      font-size: 96px;
      line-height: 1;
    }

    /* Debug UI */
    #debugWrap {
      position: fixed; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.65);
      color: rgba(255,255,255,0.88);
      font-size: 12px;
      box-sizing: border-box;
      backdrop-filter: blur(6px);
      border-top: 1px solid rgba(255,255,255,0.12);
    }

    #debugBar {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
    }

    #debugLog {
      max-height: 34vh;
      overflow: auto;
      padding: 0 12px 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap;
      line-height: 1.25;
      opacity: 0.95;
    }

    /* Safe-area handling on iOS */
    .safePad {
      padding-bottom: calc(24px + env(safe-area-inset-bottom));
      padding-top: calc(24px + env(safe-area-inset-top));
    }
  </style>
</head>

<body>
  <!-- Welcome / unlock screen -->
  <div id="welcome" class="screen safePad">
    <div id="welcomeTitle" style="font-size: 22px; font-weight: 650;">SHOWING</div>
    <div id="welcomeInfo" class="hint"></div>

    <button id="startBtn">Bist du bereit?</button>
    <!--<button id="fsBtn" class="secondary">Fullscreen</button>-->

    <div id="welcomeTip" class="hint">
      Tip: <span class="mono">?p=1</span>, <span class="mono">?p=2</span>, ‚Ä¶ or <span class="mono">?p=random</span>.
      Add <span class="mono">&debug=true</span> for diagnostics.
    </div>
    <div id="welcomeError" class="hint" style="color:#ffb3b3;"></div>
  </div>

  <!-- Main stage -->
  <div id="stage" class="hidden">
    <img id="imgCue" alt="" />
    <div id="layer" class="safePad" aria-live="polite">
      <div id="textCue"></div>
      <div id="audioCue" aria-hidden="true">üéß</div>
    </div>
  </div>

  <!-- Debug UI (only visible when debug=true) -->
  <div id="debugWrap" class="hidden">
    <div id="debugBar">
      <div id="dbgLeft"></div>
      <div id="dbgRight"></div>
    </div>
    <div id="debugLog"></div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  function parseQuery() {
    const u = new URL(window.location.href);
    const dbg = (u.searchParams.get("debug") || "").toLowerCase();
    const pRaw = (u.searchParams.get("p") || "1").toLowerCase().trim();
    return {
      csv: u.searchParams.get("csv") || "",
      pRaw, // "1".."N" or "random"/"r"
      debug: (dbg === "1" || dbg === "true" || dbg === "yes")
    };
  }

  function nowLocalHMS() {
    const d = new Date();
    const hh = String(d.getHours()).padStart(2, "0");
    const mm = String(d.getMinutes()).padStart(2, "0");
    const ss = String(d.getSeconds()).padStart(2, "0");
    return `${hh}:${mm}:${ss}`;
  }

  function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  // Minimal CSV parser (handles quotes)
  function parseCSV(text) {
    const rows = [];
    let row = [];
    let cell = "";
    let inQuotes = false;

    for (let i = 0; i < text.length; i++) {
      const c = text[i];
      const n = text[i + 1];

      if (c === '"' && inQuotes && n === '"') { cell += '"'; i++; continue; }
      if (c === '"') { inQuotes = !inQuotes; continue; }

      if (!inQuotes && (c === "," || c === "\n" || c === "\r")) {
        if (c === "\r" && n === "\n") i++;
        row.push(cell.trim());
        cell = "";
        if (c !== ",") {
          if (row.some(v => v.length > 0)) rows.push(row);
          row = [];
        }
        continue;
      }

      cell += c;
    }

    if (cell.length || row.length) {
      row.push(cell.trim());
      if (row.some(v => v.length > 0)) rows.push(row);
    }

    return rows;
  }


  // helper functions for iOS devices
  function isIOS() {
    return /iPad|iPhone|iPod/.test(navigator.userAgent)
      && !window.MSStream;
  }
  
  function isStandaloneIOS() {
    // true when launched from "Add to Home Screen"
    return window.navigator.standalone === true;
  }

  // "<timeSpec> <ACTION=...>"
  // timeSpec: "0:0:0+6s" or "20:34:00+23s" with optional jitter: "+3(r10)s"
  function parseCueLine(line) {
    const trimmed = (line || "").trim();
    if (!trimmed) return null;
  
    // Split into "<timeSpec> <actionSpec>" using ANY whitespace (space/tab/newline)
    const m0 = trimmed.match(/^(\S+)\s+([\s\S]+)$/);
    if (!m0) {
      return { raw: trimmed, error: "Missing whitespace between timeSpec and action." };
    }
  
    const timeSpec = m0[1].trim();
    const actionSpec = m0[2].trim();
  
    // timeSpec: "0:0:0+6s" or "20:34:00+23s" with optional jitter: "+3(r10)s"
    const m = timeSpec.match(/^(\d{1,2}):(\d{1,2}):(\d{1,2})\+(\d+)(?:\(r(\d+)\))?s$/);
    if (!m) {
      return { raw: trimmed, error: `Bad timeSpec: "${timeSpec}"` };
    }
  
    const hh = parseInt(m[1], 10);
    const mm = parseInt(m[2], 10);
    const ss = parseInt(m[3], 10);
    const plus = parseInt(m[4], 10);
    const jitter = m[5] ? parseInt(m[5], 10) : 0;
    const jitterAdd = jitter > 0 ? Math.floor(Math.random() * (jitter + 1)) : 0;
  
    // NEWLINE-SAFE action parsing: ([\s\S]*) matches everything incl. newlines
    const actionMatch = actionSpec.match(/^([A-Z&]+)=([\s\S]*)$/);
    if (!actionMatch) {
      return { raw: trimmed, error: `Bad actionSpec: "${actionSpec}"` };
    }
  
    const kind = actionMatch[1].trim().toUpperCase();
    const payload = (actionMatch[2] || "").trim();
  
    let action = { kind, payload };
  
    if (kind === "SOUND&IMAGE") {
      // allow newline OR spaces between URLs
      const parts = payload.split(/\s+/).filter(Boolean);
      if (parts.length < 2) return { raw: trimmed, error: "SOUND&IMAGE needs soundUrl and imageUrl." };
      action = { kind, soundUrl: parts[0], imageUrl: parts.slice(1).join(" ") };
    } else if (kind === "SOUND&TEXT") {
      const parts = payload.split(/\s+/).filter(Boolean);
      if (parts.length < 2) return { raw: trimmed, error: "SOUND&TEXT needs a soundUrl then text." };
      action = { kind, soundUrl: parts[0], text: parts.slice(1).join(" ") };
    } else if (kind === "SOUND") {
      action = { kind, soundUrl: payload };
    } else if (kind === "IMAGE") {
      action = { kind, imageUrl: payload };
    } else if (kind === "TEXT") {
      action = { kind, text: payload };
    } else if (kind === "CMD") {
      action = { kind, command: payload };
    }
  
    return { raw: trimmed, timeSpec: { hh, mm, ss, plus, jitterAdd }, action };
  }


  function computeDuePerfMs(timeSpec, startDate, startPerfNow) {
    const { hh, mm, ss, plus, jitterAdd } = timeSpec;
    const isRelative = (hh === 0 && mm === 0 && ss === 0);

    if (isRelative) {
      return startPerfNow + (plus + jitterAdd) * 1000;
    }

    const base = new Date(startDate);
    base.setHours(hh, mm, ss, 0);
    const dueWall = new Date(base.getTime() + (plus + jitterAdd) * 1000);

    if (dueWall.getTime() < startDate.getTime()) {
      dueWall.setDate(dueWall.getDate() + 1);
    }

    return startPerfNow + (dueWall.getTime() - startDate.getTime());
  }

  const els = {
    welcome: $("welcome"),
    welcomeTitle: $("welcomeTitle"),
    welcomeInfo: $("welcomeInfo"),
    welcomeTip: $("welcomeTip"),
    welcomeError: $("welcomeError"),
    startBtn: $("startBtn"),
    fsBtn: $("fsBtn"),
    stage: $("stage"),
    layer: $("layer"),
    textCue: $("textCue"),
    imgCue: $("imgCue"),
    audioCue: $("audioCue"),
    debugWrap: $("debugWrap"),
    dbgLeft: $("dbgLeft"),
    dbgRight: $("dbgRight"),
    debugLog: $("debugLog"),
  };

  function clearStage() {
    els.textCue.textContent = "";
    els.textCue.style.fontSize = "24px";
    els.imgCue.style.display = "none";
    els.imgCue.src = "";
    els.audioCue.style.display = "none";
  }

  function fitTextToBox(text) {
    els.textCue.textContent = text;

    const boxW = els.layer.clientWidth - 48;
    const boxH = els.layer.clientHeight - 48;

    let lo = 10, hi = 240, best = lo;
    while (lo <= hi) {
      const mid = Math.floor((lo + hi) / 2);
      els.textCue.style.fontSize = mid + "px";
      const r = els.textCue.getBoundingClientRect();
      const fits = (r.width <= boxW + 1) && (r.height <= boxH + 1);
      if (fits) { best = mid; lo = mid + 1; }
      else { hi = mid - 1; }
    }
    els.textCue.style.fontSize = best + "px";
  }

  async function playSound(url, audioCtx, debugLogFn) {
    const cleanUrl = (url || "").trim();
    if (!cleanUrl) return;

    if (location.protocol === "https:" && cleanUrl.startsWith("http:")) {
      debugLogFn?.(`Audio blocked (mixed content): ${cleanUrl}`);
      throw new Error("Mixed content (http audio on https page).");
    }

    // WebAudio (works well with local assets)
    if (audioCtx) {
      try {
        const res = await fetch(cleanUrl, { mode: "cors", cache: "no-store" });
        if (!res.ok) throw new Error(`Fetch ${res.status} ${res.statusText}`);
        const buf = await res.arrayBuffer();
        const audioBuffer = await audioCtx.decodeAudioData(buf);

        const src = audioCtx.createBufferSource();
        src.buffer = audioBuffer;
        src.connect(audioCtx.destination);
        src.start();

        debugLogFn?.(`WebAudio OK: ${cleanUrl}`);
        return;
      } catch (e) {
        debugLogFn?.(`WebAudio failed: ${e.message}`);
      }
    }

    // HTMLAudio fallback
    const a = new Audio(cleanUrl);
    a.preload = "auto";
    a.crossOrigin = "anonymous";
    await a.play();
    debugLogFn?.(`HTMLAudio OK: ${cleanUrl}`);
  }

  async function showAction(action, audioCtx, debugLog) {
    clearStage();

    if (action.kind === "TEXT") {
      els.audioCue.style.display = "none";
      els.textCue.style.display = "block";
      fitTextToBox(action.text || "");
      return;
    }

    if (action.kind === "IMAGE") {
      els.textCue.textContent = "";
      els.textCue.style.display = "none";
      els.audioCue.style.display = "none";
      els.imgCue.style.display = "block";
      els.imgCue.src = action.imageUrl || "";
      return;
    }

    if (action.kind === "SOUND") {
      els.textCue.textContent = "";
      els.textCue.style.display = "none";
      els.audioCue.style.display = "block";
      await playSound(action.soundUrl || "", audioCtx, debugLog);
      return;
    }

    if (action.kind === "SOUND&IMAGE") {
      els.textCue.textContent = "";
      els.textCue.style.display = "none";
      els.imgCue.style.display = "block";
      els.imgCue.src = action.imageUrl || "";
      els.audioCue.style.display = "block";
      await playSound(action.soundUrl || "", audioCtx, debugLog);
      return;
    }

    if (action.kind === "SOUND&TEXT") {
      els.textCue.style.display = "block";
      els.audioCue.style.display = "block";
      fitTextToBox(action.text || "");
      await playSound(action.soundUrl || "", audioCtx, debugLog);
      return;
    }

    els.audioCue.style.display = "none";
    fitTextToBox(`Unknown action: ${action.kind}`);
  }

  // Force fresh fetch: cache-buster + no-store headers
  async function fetchSheetCSV(csvUrl) {
    const u = new URL(csvUrl);

    const buster = (crypto?.randomUUID?.() || `${Date.now()}-${Math.random()}`);
    u.searchParams.set("cb", buster);

    const res = await fetch(u.toString(), {
      mode: "cors",
      cache: "no-store",
      headers: {
        "Cache-Control": "no-cache",
        "Pragma": "no-cache",
      },
    });

    if (!res.ok) throw new Error(`Fetch failed: ${res.status} ${res.statusText}`);
    return await res.text();
  }

  // Retry ‚Äúrefreshdata‚Äù to chase Google‚Äôs published snapshot propagation.
  async function fetchSheetCSVWithRetries(csvUrl, debugLog, attempts = 5, delaysMs = [0, 1500, 3000, 6000, 10000]) {
    let lastText = null;

    for (let i = 0; i < attempts; i++) {
      const d = delaysMs[i] ?? 0;
      if (d > 0) {
        debugLog?.(`Refresh retry ${i + 1}/${attempts}: waiting ${d}ms‚Ä¶`);
        await sleep(d);
      } else {
        debugLog?.(`Refresh retry ${i + 1}/${attempts}: fetching‚Ä¶`);
      }

      const text = await fetchSheetCSV(csvUrl);

      if (lastText !== null && text !== lastText) {
        debugLog?.(`Refresh: detected changed CSV on attempt ${i + 1}.`);
        return text;
      }

      lastText = text;
    }

    debugLog?.(`Refresh: no change detected after ${attempts} attempts; using last fetch.`);
    return lastText;
  }

  function detectPerformerCount(rows) {
    let maxCols = 0;
    for (const r of rows) maxCols = Math.max(maxCols, r.length);

    const available = [];
    for (let c = 0; c < maxCols; c++) {
      let hasAny = false;
      for (let i = 0; i < rows.length; i++) {
        const v = (rows[i][c] || "").trim();
        if (v.length > 0) { hasAny = true; break; }
      }
      if (hasAny) available.push(c + 1);
    }
    return available;
  }

  function pickColumnLines(rows, performerIndex1Based) {
    const col = Math.max(1, performerIndex1Based) - 1;
    return rows.map(r => (r[col] || "").trim()).filter(v => v.length > 0);
  }

  function buildCuesFromLines(lines) {
    const cues = [];
    const errors = [];
    for (const ln of lines) {
      const cue = parseCueLine(ln);
      if (!cue) continue;
      if (cue.error) errors.push(cue);
      else cues.push(cue);
    }
    return { cues, errors };
  }

  function isRefreshCommand(action) {
    if (!action || action.kind !== "CMD") return false;
    const cmd = String(action.command || "").trim().toLowerCase();
    return (cmd === "refreshdata" || cmd === "refresh" || cmd === "refresh-data");
  }

  async function requestFullscreen() {
    const el = document.documentElement;
    try {
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    } catch (_) {}
  }

  async function run() {
    const q = parseQuery();

    if (!q.debug) {
      els.welcomeTitle.classList.add("hidden");
      els.welcomeInfo.classList.add("hidden");
      els.welcomeTip.classList.add("hidden");
      els.welcomeError.classList.add("hidden");
      els.debugWrap.classList.add("hidden");
    } else {
      els.debugWrap.classList.remove("hidden");
    }

    const debugLog = (msg) => {
      if (!q.debug) return;
      const line = `[${nowLocalHMS()}] ${msg}`;
      console.log(line);
      els.debugLog.textContent += line + "\n";
      els.debugLog.scrollTop = els.debugLog.scrollHeight;
      els.dbgRight.textContent = `Now ${nowLocalHMS()}`;
    };

    if (q.debug) {
      debugLog("Tip: For true fullscreen on iOS, use 'Add to Home Screen'.");
    }
    // iOS fullscreen hint (shown even without debug)
    if (isIOS() && !isStandaloneIOS()) {
      const msg = document.createElement("div");
      msg.className = "hint";
      msg.style.maxWidth = "32rem";
      msg.style.opacity = "0.7";
      msg.style.fontSize = "14px";
      msg.style.marginTop = "12px";
      msg.textContent =
        "For a fully immersive experience on iPhone/iPad, use ‚ÄúAdd to Home Screen‚Äù.";
    
      // Append below the Start button
      els.welcome.appendChild(msg);
    }


    if (!q.csv) {
      els.startBtn.disabled = true;
      if (q.debug) {
        els.welcomeTitle.classList.remove("hidden");
        els.welcomeInfo.classList.remove("hidden");
        els.welcomeTip.classList.remove("hidden");
        els.welcomeError.classList.remove("hidden");
        els.welcomeInfo.innerHTML = `Missing <span class="mono">?csv=...</span> URL parameter.`;
      }
      return;
    }

    if (q.debug) {
      els.welcomeTitle.classList.remove("hidden");
      els.welcomeInfo.classList.remove("hidden");
      els.welcomeTip.classList.remove("hidden");
      els.welcomeError.classList.remove("hidden");
      els.welcomeInfo.innerHTML =
        `CSV: <span class="mono">${q.csv.replaceAll("<","&lt;").replaceAll(">","&gt;")}</span><br>
         p: <span class="mono">${q.pRaw}</span>`;
      els.dbgLeft.textContent = `Loading CSV‚Ä¶`;
    }

    // Initial fetch+parse
    let raw;
    try {
      raw = await fetchSheetCSV(q.csv);
      debugLog(`CSV fetched (${raw.length} chars).`);
    } catch (e) {
      els.startBtn.disabled = true;
      debugLog(`CSV fetch failed: ${e.message}`);
      if (q.debug) els.welcomeError.textContent = `Could not fetch CSV. Error: ${e.message}`;
      return;
    }

    const rows = parseCSV(raw);
    const availablePerformers = detectPerformerCount(rows);
    if (availablePerformers.length === 0) {
      els.startBtn.disabled = true;
      debugLog("No performer columns with any data.");
      if (q.debug) els.welcomeError.textContent = "No performer columns with any data.";
      return;
    }

    let pSelected;
    if (q.pRaw === "random" || q.pRaw === "r") {
      pSelected = availablePerformers[Math.floor(Math.random() * availablePerformers.length)];
      debugLog(`p=random ‚Üí selected performer p=${pSelected} from [${availablePerformers.join(", ")}]`);
    } else {
      const pNum = parseInt(q.pRaw, 10);
      pSelected = Number.isFinite(pNum) && pNum > 0 ? pNum : 1;
      debugLog(`Selected performer p=${pSelected}`);
    }

    let lines = pickColumnLines(rows, pSelected);
    let built = buildCuesFromLines(lines);
    let cues = built.cues;
    let errors = built.errors;

    debugLog(`Rows parsed: ${rows.length}`);
    debugLog(`Available performers: [${availablePerformers.join(", ")}]`);
    debugLog(`Lines in column p=${pSelected}: ${lines.length}`);
    debugLog(`Cues OK: ${cues.length}, errors: ${errors.length}`);

    if (q.debug) {
      els.dbgLeft.textContent = `Loaded ${cues.length} cues (p=${pSelected})`;
      if (errors.length) {
        els.welcomeError.textContent =
          "Some lines could not be parsed:\n" +
          errors.slice(0, 10).map(e => `- ${e.raw}  (${e.error})`).join("\n");
      } else {
        els.welcomeError.textContent = "";
      }
      cues.slice(0, 10).forEach((c, i) => debugLog(`Cue[${i}]: ${c.raw}`));
    }

    els.startBtn.addEventListener("click", async () => {
      await requestFullscreen();

      els.welcome.classList.add("hidden");
      els.stage.classList.remove("hidden");

      // Unlock audio
      let audioCtx = null;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        gain.gain.value = 0.00001;
        osc.connect(gain).connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.01);
        await audioCtx.resume();
        debugLog(`AudioContext state: ${audioCtx.state}`);
      } catch (e) {
        debugLog(`AudioContext unavailable/unlock failed: ${e.message}`);
      }

      const startDate = new Date();
      const startPerf = performance.now();
      debugLog(`START pressed. Start wall time: ${startDate.toLocaleTimeString()}`);

      const firedRaw = new Set();

      const rebuildSchedule = () => {
        const nowPerf = performance.now();
        return cues.map((c, idx) => ({
          idx,
          cue: c,
          duePerfMs: computeDuePerfMs(c.timeSpec, startDate, startPerf)
        }))
        .filter(item => item.duePerfMs > nowPerf + 20 && !firedRaw.has(item.cue.raw))
        .sort((a, b) => a.duePerfMs - b.duePerfMs || a.idx - b.idx);
      };

      let scheduled = rebuildSchedule();
      debugLog(`Initial pending cues: ${scheduled.length}`);
      let i = 0;

      while (i < scheduled.length) {
        const item = scheduled[i];

        const waitMs = Math.max(0, item.duePerfMs - performance.now());
        if (waitMs > 0) await sleep(waitMs);

        firedRaw.add(item.cue.raw);

        if (q.debug) {
          els.dbgLeft.textContent = `Cue ${i + 1}/${scheduled.length} (p=${pSelected})`;
          debugLog(`FIRE: ${item.cue.raw}`);
        }

        // Refresh command: retry-fetch to chase Google publish lag
        if (isRefreshCommand(item.cue.action)) {
          debugLog("CMD=refreshdata ‚Üí fetching latest CSV (with retries)‚Ä¶");
          try {
            const newRaw = await fetchSheetCSVWithRetries(q.csv, debugLog);
            const newRows = parseCSV(newRaw);
            const newLines = pickColumnLines(newRows, pSelected);
            const newBuilt = buildCuesFromLines(newLines);

            cues = newBuilt.cues;
            errors = newBuilt.errors;

            debugLog(`Refresh OK: cues=${cues.length}, errors=${errors.length}`);
            scheduled = rebuildSchedule();
            debugLog(`After refresh, pending cues: ${scheduled.length}`);
            i = 0;
            continue; // invisible to user
          } catch (e) {
            debugLog(`Refresh FAILED: ${e.message}`);
            i++;
            continue;
          }
        }

        try {
          await showAction(item.cue.action, audioCtx, debugLog);
        } catch (e) {
          debugLog(`Action failed: ${e.message}`);
        }

        i++;
      }

      // End
      els.audioCue.style.display = "none";
      els.imgCue.style.display = "none";
      els.textCue.style.display = "block";
      fitTextToBox("‚Äî end ‚Äî");
      debugLog("END.");
    }, { once: true });
  }

  run();
})();
</script>
</body>
</html>
